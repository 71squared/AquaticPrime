#tag ClassClass AquaticPrime	#tag Method, Flags = &h0		Sub AddToBlacklist(newHash as string)		  		  mblacklist.append newHash		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function CFMutableDictionaryFromRBDictionary(dict as dictionary) As integer		  		  #if targetMacOS		    		    Soft Declare Sub CFRelease Lib CoreFoundationLib (cf as Integer)		    Soft Declare Sub CFDictionaryAddValue Lib CoreFoundationLib (theDict as integer, key as integer, value as integer)		    Soft Declare Function CFDictionaryCreateMutable Lib CoreFoundationLib (allocator as Integer, capacity as integer, keyCallBacks as Ptr, valueCallBacks as Ptr) as Integer		    Soft Declare Function CFBundleGetBundleWithIdentifier Lib CoreFoundationLib (bundleID as Integer) as Integer		    Soft Declare Function CFBundleGetDataPointerForName Lib CoreFoundationLib (bundle as Integer, symbolName as Integer) as Integer		    		    if dict = nil then		      return 0		    end if		    		    dim bundle as integer		    dim keyCallbacks as new MemoryBlock(4)		    dim valueCallbacks as new MemoryBlock(4)		    		    dim bundleID as integer = CFStringFromRBString(kCoreFoundationBundleID)		    bundle = CFBundleGetBundleWithIdentifier(bundleID)		    		    dim keyCallbacksCFStr as integer = CFStringFromRBString(kCFTypeDictionaryKeyCallBacks)		    keyCallbacks.Long(0) = CFBundleGetDataPointerForName(bundle, keyCallbacksCFStr)		    if keyCallbacks.Long(0) <> 0 then		      keyCallbacks = keyCallbacks.Ptr(0)		    else		      keyCallbacks = nil		    end if		    		    dim valueCallbacksCFStr as integer = CFStringFromRBString(kCFTypeDictionaryValueCallBacks)		    valueCallbacks.Long(0) = CFBundleGetDataPointerForName(bundle, valueCallbacksCFStr)		    if valueCallbacks.Long(0) <> 0 then		      valueCallbacks = valueCallbacks.Ptr(0)		    else		      valueCallbacks = nil		    end if		    		    dim retCFDict as integer = CFDictionaryCreateMutable(kCFAllocatorDefault, dict.count, keyCallbacks, valueCallbacks)		    		    CFRelease(valueCallbacksCFStr)		    CFRelease(keyCallbacksCFStr)		    CFRelease(bundle)		    CFRelease(bundleID)		    		    dim n as integer = dict.count-1		    for i as integer = 0 to n		      dim keyCFString as integer = CFStringFromRBString(dict.key(i))		      dim valueCFString as integer = CFStringFromRBString(dict.value(dict.key(i)))		      CFDictionaryAddValue(retCFDict, keyCFString, valueCFString)		      CFRelease(keyCFString)		      CFRelease(valueCFString)		    next		    		    return retCFDict		    		  #endif		  		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function CFStringFromRBString(s as string) As integer		  		  #if targetMacOS		    		    Soft Declare Function CFStringCreateWithCString Lib CoreFoundationLib (alloc as Integer, cStr as CString, encoding as Integer) As integer		    		    dim CFString as integer		    		    if Encoding(s) <> nil then		      CFString = CFStringCreateWithCString(kCFAllocatorDefault, s, Encoding(s).code)		    else		      CFString = CFStringCreateWithCString(kCFAllocatorDefault, s, kCFStringEncodingASCII)		    end if		    		    return CFString		    		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub Constructor()		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(publicKey as string, privateKey as string = "")		  		  #if targetMacOS		    		    Soft Declare Sub ERR_load_crypto_strings Lib CryptoLib ()		    		    ERR_load_crypto_strings		    		    self.SetKey publicKey, privateKey		    		  #endif		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Destructor()		  		  #if targetMacOS		    		    Soft Declare Sub ERR_free_strings Lib CryptoLib ()		    Soft Declare Sub RSA_free Lib CryptoLib (r as Ptr)		    		    ERR_free_strings		    		    if rsaKey <> nil then		      RSA_free(rsaKey)		    end if		    		  #endif		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function DictionaryForLicenseData(licenseData as string) As dictionary		  		  #if targetMacOS		    		    Soft Declare Function CFDataCreate Lib CoreFoundationLib (allocator as Integer, bytes as CString, length as Integer) As integer		    Soft Declare Function CFPropertyListCreateFromXMLData Lib CoreFoundationLib (allocator as Integer, xmlData as Integer, mutabilityOptions as Integer, byRef errorString as Integer) As integer		    Soft Declare Function CFDictionaryContainsKey Lib CoreFoundationLib (theDict as Integer, key as Integer) As boolean		    Soft Declare Function CFDictionaryGetValue Lib CoreFoundationLib (theDict as Integer, key as Integer) As integer		    Soft Declare Function CFStringCreateMutable Lib CoreFoundationLib (alloc as integer, maxLength as integer) As integer		    Soft Declare Function CFDictionaryGetCount Lib CoreFoundationLib (theDict as integer) As integer		    Soft Declare Sub CFRelease Lib CoreFoundationLib (cf as Integer)		    Soft Declare Sub CFDataGetBytes Lib CoreFoundationLib (theData as Integer, loc as integer, leng as integer, buffer as Ptr)		    Soft Declare Sub CFDictionaryRemoveValue Lib CoreFoundationLib (theDict as integer, key as integer)		    Soft Declare Sub CFStringAppendFormat Lib CoreFoundationLib (theString as integer, formatOptions as integer, format1 as integer, format2 as integer)		    Soft Declare Sub CFDictionaryGetKeysAndValues Lib CoreFoundationLib (theDict as Integer, keys as Ptr, values as Ptr)		    		    Soft Declare Function RSA_public_decrypt Lib CryptoLib (flen as integer, from as Ptr, mto as Ptr, rsa as Ptr, padding as integer) As integer		    Soft Declare Function ERR_error_string Lib CryptoLib (e as UInt32, buf as Ptr) As CString		    Soft Declare Function ERR_get_error Lib CryptoLib () As UInt32		    Soft Declare Function SHA1_Init Lib CryptoLib (c as Ptr) As integer		    Soft Declare Function SHA1_Update Lib CryptoLib (c as Ptr, data as CString, mlen as UInt32) As integer		    Soft Declare Function SHA1_Final Lib CryptoLib (md as Ptr, c as Ptr) As integer		    		    		    // Make sure public key is set up		    if rsaKey = nil or rsaKey.UInt32Value(16) = 0 then		      self.SetError "RSA key is invalid"		      return nil		    end if		    		    // Make CFData from REALbasic string		    dim dataRef as Integer = CFDataCreate(kCFAllocatorDefault, licenseData, LenB(licenseData))		    if dataRef = 0 then		      return nil		    end if		    		    // Make the property list from the data		    dim propertyList as integer		    dim errorString as integer		    propertyList = CFPropertyListCreateFromXMLData(kCFAllocatorDefault, dataRef, kCFPropertyListMutableContainers, errorString)		    if propertyList = 0 then		      CFRelease dataRef		      return nil		    end if		    		    dim myDict as integer = propertyList		    		    // Create a CFString for "Signature"		    dim sigCFString as integer = CFStringFromRBString("Signature")		    if sigCFString = 0 then		      CFRelease(myDict)		      return nil		    end if		    		    // Load the signature		    dim sigBytes as new MemoryBlock(128)		    if not CFDictionaryContainsKey(myDict, sigCFString) then		      CFRelease(myDict)		      CFRelease(sigCFString)		      return nil		    end if		    dim sigData as integer = CFDictionaryGetValue(myDict, sigCFString)		    CFDataGetBytes(sigData, 0, 128, sigBytes)		    		    // Remove the signature element		    CFDictionaryRemoveValue(myDict, sigCFString)		    		    // Decrypt the signature - should get 20 bytes back		    dim checkDigest as new MemoryBlock(20)		    if RSA_public_decrypt(128, sigBytes, checkDigest, rsaKey, RSA_PKCS1_PADDING) <> SHA_DIGEST_LENGTH then		      self.SetError ERR_error_string(ERR_get_error(), nil)		      CFRelease(myDict)		      CFRelease(sigCFString)		      return nil		    end if		    		    // Create a CFString for "%02x"		    dim formatCFString as integer = CFStringFromRBString("%02x")		    if formatCFString = 0 then		      CFRelease(myDict)		      CFRelease(sigCFString)		      return nil		    end if		    		    // Get the license hash		    dim hashCheck as integer = CFStringCreateMutable(kCFAllocatorDefault, 0)		    dim hashIndex, n as integer		    n = SHA_DIGEST_LENGTH-1		    for hashIndex = 0 to n		      CFStringAppendFormat(hashCheck, 0, formatCFString, checkDigest.byte(hashIndex))		    next		    		    // Store the license hash in case we need it later		    self.SetHash hashCheck		    		    // Release CF resources no more needed		    CFRelease(hashCheck)		    CFRelease(sigCFString)		    CFRelease(formatCFString)		    		    // Make sure the license hash isn't on the blacklist		    if mblacklist.indexOf(hash) <> -1 then		      CFRelease(myDict)		      return nil		    end if		    		    // Get the number of elements		    dim count as integer = CFDictionaryGetCount(myDict)		    		    // Load the keys and values pairs and build up the key and values arrays		    dim keyArray() as string		    dim valueArray() as string		    redim keyArray(count-1)		    redim valueArray(count-1)		    dim keyList as new MemoryBlock(4*count)		    dim valueList as new MemoryBlock(4*count)		    CFDictionaryGetKeysAndValues myDict, keyList, valueList		    n = count-1		    for i as integer = 0 to n		      // Process keys and values and convert into UTF8 strings		      keyArray(i) = RBStringFromCFString(keyList.Long(4*i))		      valueArray(i) = RBStringFromCFString(valueList.Long(4*i))		    next		    		    // Sort the keys so we always have a uniform order		    keyArray.sortWith(valueArray)		    		    // Setup up the hash context		    dim ctx as new memoryBlock(96)		    call SHA1_Init(ctx)		    		    // Convert into UTF8 strings		    for i as integer = 0 to n		      call SHA1_Update(ctx, valueArray(i), lenB(valueArray(i)))		    next		    dim digest as new MemoryBlock(SHA_DIGEST_LENGTH)		    call SHA1_Final(digest, ctx)		    		    // Check if the signature is a match		    n = SHA_DIGEST_LENGTH-1		    for i as integer = 0 to n		      if bitwise.bitXor(checkDigest.byte(i), digest.byte(i)) <> 0 then		        CFRelease(myDict)		        return nil		      end if		    next		    		    // If it's a match, we return the dictionary; otherwise, we never reach this		    		    // Build a RB dictionary to return		    dim retDict as new dictionary		    n = ubound(keyArray)		    for i as integer = 0 to n		      retDict.value(keyArray(i)) = valueArray(i)		    next		    		    return retDict		    		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function DictionaryForLicenseFile(licenseFile as folderItem) As dictionary		  		  #if targetMacOS		    		    // Read the XML file		    dim licenseStream as binaryStream		    dim data as string		    		    if licenseFile = nil or not licenseFile.exists or not licenseFile.isReadable then		      return nil		    end if		    		    licenseStream = BinaryStream.Open(licenseFile)		    if licenseStream = nil then		      return nil		    end if		    		    data = licenseStream.read(licenseStream.length)		    licenseStream.close		    		    return DictionaryForLicenseData(data)		    		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function LicenseDataForDictionary(dict as dictionary) As string		  		  #if targetMacOS		    		    Soft Declare Sub CFRelease Lib CoreFoundationLib (cf as Integer)		    Soft Declare Sub CFDictionaryAddValue Lib CoreFoundationLib (theDict as integer, key as integer, value as integer)		    Soft Declare Sub CFDataGetBytes Lib CoreFoundationLib (theData as Integer, loc as integer, leng as integer, buffer as Ptr)		    Soft Declare Function CFDataCreate Lib CoreFoundationLib (allocator as Integer, bytes as CString, length as Integer) As integer		    Soft Declare Function CFPropertyListCreateXMLData Lib CoreFoundationLib (allocator as integer, propertyList as integer) as integer		    Soft Declare Function CFDataGetLength Lib CoreFoundationLib (theData as integer) as integer		    		    Soft Declare Function SHA1 Lib CryptoLib (d as Ptr, n as UInt32, md as Ptr) As Ptr		    Soft Declare Function RSA_size Lib CryptoLib (RSA as Ptr) as Integer		    Soft Declare Function RSA_private_encrypt Lib CryptoLib (flen as Integer, from as Ptr, mto as Ptr, rsa as Ptr, padding as integer) as integer		    Soft Declare Function ERR_error_string Lib CryptoLib (e as UInt32, buf as Ptr) As CString		    Soft Declare Function ERR_get_error Lib CryptoLib () As UInt32		    		    // Make sure we have a good key		    if rsaKey = nil or rsaKey.UInt32Value(16) = 0 or rsaKey.UInt32Value(24) = 0 then		      self.SetError "RSA key is invalid"		      return ""		    end if		    		    // Grab all values from the dictionary		    dim keyArray() as string		    dim dictData as new memoryBlock(1)		    dim n as integer = dict.count-1		    redim keyArray(n)		    for i as integer = 0 to n		      keyArray(i) = dict.key(i)		    next		    		    // Sort the keys so we always have a uniform order		    keyArray.Sort		    dim oldSize as integer = 0		    for i as integer = 0 to n		      dim curValue as string = dict.value(keyArray(i))		      dictData.size = oldSize+lenB(curValue)		      dictData.StringValue(oldSize, lenB(curValue)) = curValue		      oldSize = dictData.size		    next		    		    // Hash the data		    dim digest as new memoryBlock(20)		    call SHA1(dictData, dictData.size, digest)		    		    // Create the signature from 20 byte hash		    dim rsaLength as integer = RSA_size(rsaKey)		    dim signature as new memoryBlock(rsaLength)		    dim bytes as integer = RSA_private_encrypt(20, digest, signature, rsaKey, RSA_PKCS1_PADDING)		    		    if bytes = -1 then		      self.SetError ERR_error_string(ERR_get_error(), nil)		      return ""		    end if		    		    // Create the license dictionary		    dim licenseDict as integer = CFMutableDictionaryFromRBDictionary(dict)		    dim sigKeyCFString as integer = CFStringFromRBString("Signature")		    dim sigValCFData as integer = CFDataCreate(kCFAllocatorDefault, signature.stringValue(0, bytes), bytes)		    CFDictionaryAddValue(licenseDict, sigKeyCFString, sigValCFData)		    		    // Create the data from the dictionary		    dim licenseFile as integer = CFPropertyListCreateXMLData(kCFAllocatorDefault, licenseDict)		    		    if licenseFile = 0 then		      CFRelease(licenseDict)		      CFRelease(sigKeyCFString)		      CFRelease(sigValCFData)		      return ""		    end if		    		    // Create a RB string from CFData		    dim dataLen as integer = CFDataGetLength(licenseFile)		    dim dataBytes as new memoryBlock(dataLen)		    CFDataGetBytes(licenseFile, 0, dataLen, dataBytes)		    		    CFRelease(licenseDict)		    CFRelease(licenseFile)		    CFRelease(sigKeyCFString)		    CFRelease(sigValCFData)		    		    return defineEncoding(dataBytes.stringValue(0, dataLen), Encodings.UTF8)		    		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function MemAddress(m as memoryBlock) As UInt32		  		  dim mAddr as new memoryBlock(4)		  		  mAddr.ptr(0) = m		  		  return mAddr.UInt32Value(0)		  		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function RBStringFromCFString(c as integer) As string		  		  #if targetMacOS		    		    Soft Declare Function CFStringGetLength Lib CoreFoundationLib (theString as Integer) As integer		    Soft Declare Function CFStringGetMaximumSizeForEncoding Lib CoreFoundationLib (length as Integer, enc as Integer) As integer		    Soft Declare Function CFStringGetCString Lib CoreFoundationLib (theString as Integer, buffer as Ptr, bufferSize as Integer, enc as Integer) As boolean		    		    dim charCount as Integer		    dim maxSize as Integer		    dim buffer as MemoryBlock		    		    charCount = CFStringGetLength(c)		    maxSize = CFStringGetMaximumSizeForEncoding(charCount, kCFStringEncodingUTF8)		    buffer = new MemoryBlock(1 + maxSize) //one extra byte for CString terminator		    if CFStringGetCString(c, buffer, buffer.Size, kCFStringEncodingUTF8) then		      return Left(DefineEncoding(buffer.StringValue(0, maxSize), Encodings.UTF8), charCount)		    else		      return ""		    end if		    		  #endif		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub SetBlacklist(hashArray() as string)		  		  dim u as Integer = UBound(hashArray)		  redim mblacklist(u)		  		  for i as Integer = 0 to u		    mblacklist(i) = hashArray(i)		  next		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetError(err as string)		  		  aqError = err		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetHash(hashCFString as integer)		  		  mhash = RBStringFromCFString(hashCFString)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetKey(key as string, privateKey as string = "")		  		  #if targetMacOS		    		    Soft Declare Sub RSA_free Lib CryptoLib (r as Ptr)		    Soft Declare Function RSA_new Lib CryptoLib () As Ptr		    Soft Declare Function BN_dec2bn Lib CryptoLib (a as UInt32, str as CString) As integer		    Soft Declare Function BN_hex2bn Lib CryptoLib (a as UInt32, str as CString) As integer		    Soft Declare Function ERR_get_error Lib CryptoLib () As UInt32		    Soft Declare Function ERR_error_string Lib CryptoLib (e as UInt32, buf as Ptr) As CString		    		    		    // Must have public modulus, private key is optional		    if key = "" then		      self.SetError "Empty public key parameter"		      return		    end if		    		    if rsaKey <> nil then		      RSA_free(rsaKey)		    end if		    		    rsaKey = RSA_new()		    		    // We are using the constant public exponent e = 3		    call BN_dec2bn(MemAddress(rsaKey)+20, "3")		    		    // Determine if we have hex or decimal values		    dim result as integer		    		    if left(key, 2) = "0x" then		      result = BN_hex2bn(MemAddress(rsaKey)+16, mid(key, 3))		    else		      result = BN_dec2bn(MemAddress(rsaKey)+16, key)		    end if		    		    if result = 0 then		      self.SetError ERR_error_string(ERR_get_error(), nil)		      return		    end if		    		    // Do the private portion if it exists		    if privateKey <> "" then		      if left(privateKey, 2) = "0x" then		        result = BN_hex2bn(MemAddress(rsaKey)+24, mid(privateKey, 3))		      else		        result = BN_dec2bn(MemAddress(rsaKey)+24, privateKey)		      end if		      		      if result = 0 then		        self.SetError ERR_error_string(ERR_get_error(), nil)		        return		      end if		    end if		    		  #endif		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function VerifyLicenseData(data as string) As boolean		  		  return (self.DictionaryForLicenseData(data) <> nil)		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function VerifyLicenseFile(file as folderItem) As boolean		  		  return (self.DictionaryForLicenseFile(file) <> nil)		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function WriteLicenseFileForDictionary(dict as dictionary, file as folderItem) As boolean		  		  dim licenseFile as string = self.LicenseDataForDictionary(dict)		  		  if licenseFile = "" then		    return false		  end if		  		  if file = nil or not file.isWriteable then		    return false		  end if		  		  dim licenseStream as BinaryStream = BinaryStream.Create(file, true)		  if licenseStream = nil then		    return false		  end if		  		  licenseStream.write(licenseFile)		  licenseStream.close		  		  return true		  		End Function	#tag EndMethod	#tag Note, Name = Legal				AquaticPrime.rbp		AquaticPrime REAL Studio (REALbasic) Implementation				Copyright (c) 2010, Massimo Valle		All rights reserved.				derived and adapted from the original C/Objective-C impementation		Copyright (c) 2005, Lucas Newman		All rights reserved.				Redistribution and use in source and binary forms, with or without modification,		are permitted provided that the following conditions are met:		•Redistributions of source code must retain the above copyright notice,		this list of conditions and the following disclaimer.		•Redistributions in binary form must reproduce the above copyright notice,		this list of conditions and the following disclaimer in the documentation and/or		other materials provided with the distribution.		•Neither the name of the Aquatic nor the names of its contributors may be used to		endorse or promote products derived from this software without specific prior written permission.				THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR		IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND		FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR		CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL		DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,		DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER		IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT		OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.	#tag EndNote	#tag Property, Flags = &h21		Private aqError As string	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  			  return mhash			End Get		#tag EndGetter		hash As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  			  #if targetMacOS			    			    Soft Declare Function BN_bn2hex Lib CryptoLib (a as UInt32) As CString			    			    if rsaKey = nil or rsaKey.UInt32Value(16) = 0 then			      return ""			    end if			    			    return BN_bn2hex(MemAddress(rsaKey)+16)			    			  #endif			End Get		#tag EndGetter		Key As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  			  return aqError			  			End Get		#tag EndGetter		LastError As string	#tag EndComputedProperty	#tag Property, Flags = &h21		Private mblacklist() As string	#tag EndProperty	#tag Property, Flags = &h21		Private mhash As string	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  			  #if targetMacOS			    			    Soft Declare Function BN_bn2hex Lib CryptoLib (a as UInt32) As CString			    			    if rsaKey = nil or rsaKey.UInt32Value(24) = 0 then			      return ""			    end if			    			    return BN_bn2hex(MemAddress(rsaKey)+24)			    			  #endif			End Get		#tag EndGetter		PrivateKey As string	#tag EndComputedProperty	#tag Property, Flags = &h21		Private rsaKey As memoryBlock	#tag EndProperty	#tag Constant, Name = CoreFoundationLib, Type = String, Dynamic = False, Default = \"CoreFoundation", Scope = Private	#tag EndConstant	#tag Constant, Name = CryptoLib, Type = String, Dynamic = False, Default = \"libcrypto.dylib", Scope = Private	#tag EndConstant	#tag Constant, Name = kCFAllocatorDefault, Type = Double, Dynamic = False, Default = \"0", Scope = Private	#tag EndConstant	#tag Constant, Name = kCFPropertyListMutableContainers, Type = Double, Dynamic = False, Default = \"1", Scope = Private	#tag EndConstant	#tag Constant, Name = kCFPropertyListXMLFormat_v1_0, Type = Double, Dynamic = False, Default = \"100", Scope = Private	#tag EndConstant	#tag Constant, Name = kCFStringEncodingASCII, Type = Double, Dynamic = False, Default = \"&h0600", Scope = Private	#tag EndConstant	#tag Constant, Name = kCFStringEncodingUTF8, Type = Double, Dynamic = False, Default = \"&h08000100", Scope = Private	#tag EndConstant	#tag Constant, Name = kCFTypeDictionaryKeyCallBacks, Type = String, Dynamic = False, Default = \"kCFTypeDictionaryKeyCallBacks", Scope = Private	#tag EndConstant	#tag Constant, Name = kCFTypeDictionaryValueCallBacks, Type = String, Dynamic = False, Default = \"kCFTypeDictionaryValueCallBacks", Scope = Private	#tag EndConstant	#tag Constant, Name = kCoreFoundationBundleID, Type = String, Dynamic = False, Default = \"com.apple.CoreFoundation", Scope = Private	#tag EndConstant	#tag Constant, Name = RSA_PKCS1_PADDING, Type = Double, Dynamic = False, Default = \"1", Scope = Private	#tag EndConstant	#tag Constant, Name = SHA_DIGEST_LENGTH, Type = Double, Dynamic = False, Default = \"20", Scope = Private	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="hash"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Key"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="LastError"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="PrivateKey"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass